
### 래치(Latch)

![[Pasted image 20250630133306.png]]
**SR 래치**
기본적인 순차논리회로(메모리 회로)이다.
S, R 두 가지 입력을 받고 NOR 게이트 두 가지의 출력이 서로 Feedback 되는 구조이다.
S(Set) 입력에 1이 입력되면 출력 Q가 1이 되고, R(Reset) 입력에 1이 입력되면 Q가 0이 된다.
이때, 출력 Q와 P는 보수 관계이다.

래치는 가장 기본적인 메모리 회로이지만, 실제로 사용하는 회로라고 보기엔 어렵고 개념적으로 메모리 회로를 이해하는 데 사용한다.

S, R 입력이 동시에 모두 1이 들어오면, 회로가 불안정하게 발진하고(출력이 특정한 주기 없이 계속 1, 0으로 바뀜), 회로에 전원이 처음 인가될 시 S, R 입력이 모두 0이면 출력에 Feedback 되어있는 입력이 Floating 되어 불안정한 회로가 된다.

Vivado를 사용한 Verilog 코딩에서는 always 블록 내부에 조건문이 들어가게 되는데, **이러한 조건문 내부에 구멍이 있으면(if문에 else가 없거나, switch 문에 default가 없는 등) _자동적으로 회로에 latch가 생성_ 된다.**
조건문 중 정의되지 않은 조건이 있으면, Vivado에서 자동으로 이전 값을 저장한 후 그것을 정의되지 않은 조건에서 출력으로 사용하는데 이것 때문에 자동으로 Latch가 생성된다.


### 플립플롭(Flip Flop)

![[D.jpg]]
![[Pasted image 20250630140205.png]]
**D 플립플롭**

D 플립플롭은 SR 래치에 Clock이 추가되고, 입력을 하나로 묶은 후 한 쪽에만 NOT 게이트(D, Delay라는 이름이 여기서 나옴. NOT 게이트를 지나는데 짧은 딜레이가 있기 때문.)를 지나게 해 두 입력 모두 1, 1이 되는 상황을 방지한 회로이다.

전단의 NAND에는 D 입력과 함께 Clock을 입력으로 받는데, NAND의 특성상 어느 한 쪽의 입력이 0이면 다른 쪽의 입력과 상관 없이 무조건 1이 출력되게 된다.
이러한 이유로 Clock이 0일때는 아주 잠깐 <ins>두 NAND의 출력이 1, 1로 나와서 S, R에 모두 1이 입력되는 상황</ins>이 나오게 된다.
보통의 경우 Clock은 매우 빠른 주파수를 가지고 발진해 S, R 입력이 모두 1인 상황이 길게 유지되지 않아 사실상 이러한 경우도 0, 0 입력처럼 이전 출력이 유지된다.

하지만, 만약 1Hz와 같이 극단적으로 주기가 긴 클락이 입력되면 어떨까?
이 경우, S, R에 모두 1이 입력되는 시간이 길어져서 더이상 이전 출력이 유지되는 상황으로는 보기 어렵다.
하지만 이런 경우를 위해 **Clock을 감지할 때, level trigger(High / Low)로 감지하지 않고 _edge trigger (Rising / Falling) 으로 감지_ 해 클럭의 엣지에서만 동작**하도록 IC가 설계된다.

이러한 설계로 인해 D 플립플롭에서는 SR 래치에서 금지된 입력인 1, 1 입력을 방지할 수 있다.
