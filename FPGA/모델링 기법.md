#### 1. 기본적인 모듈 구성 / AND Gate 실습
```verilog title:"And gate"
module And_gate(
    input A,
    input B,
    output F
    );   
    assign F = A & B; 
endmodule
```
기본적으로 모든 모듈을 선언 시 'module' 로 열고 'endmodule'로 닫아야 한다.
모듈의 첫 시작 괄호 내에는 모듈이 사용할 인/아웃풋을 최초로 선언해 준다.
모든 인/아웃풋을 선언하고 괄호를 닫은 후에는 이 모듈에서 인/아웃풋의 관계를 나타내는 코드를 작성한다.

위 코드의 경우 AND 게이트의 동작을 하기 위해 출력 F를 입력 A와 B를 AND연산을 해 주었다.

![[Pasted image 20250629170035.png]]
Source에서 해당 모듈을 Top으로 설정한 이후 Open Elaborated Design을 클릭해 Schematic을 확인해 보면 정상적으로 AND Gate가 생성된 것을 확인할 수 있다.

![[Pasted image 20250629170415.png]]
Source에서 시뮬레이션도 해당 모듈을 Top으로 설정한 후 Run Simulation을 클릭해 시뮬레이션을 실행해 보면, 입력 A와 B 모두 1일때만 출력 F도 1이 나오는 AND Gate가 정상적으로 생성된 것을 확인할 수 있다.


#### 2. 구조적 모델링(Structural Modeling) 실습
```verilog title:"Half Adder_Structural"
module half_adder_structural(
    input A, B,
    output sum, carry 
    );
    xor (sum, A, B);
    and (carry, A, B);
    
endmodule
```
위의 코드는 [[반가산기]]를 구조적 모델링으로 구현한 모습이다.

구조적 모델링은 이름과 같이 하드웨어 구조, 즉 회로도 상의 실제 연결을 코드로 나타내는 모델링 기법이다.
- 장점: 하드웨어 뷰가 직관적이다, 모델링 한 것을 다른 모델링에서 하위 모듈로 재사용하기 편리하다.
- 단점: 설계 구조가 복잡해지면 회로의 모든 연결을 명시해야 하기 때문에 복잡해진다.

![[Pasted image 20250629172308.png]]
구조적 모델링으로 하드웨어를 설계 시 Schematic을 보면 예상과 같이 반가산기를 만드는데 필요한 AND 게이트와 XOR 게이트가 생성된 것을 확인할 수 있다.

![[Pasted image 20250629172524.png]]
시뮬레이션을 실행해 보면 정상적으로 입력 A, B의 합산과 캐리 계산이 되는 것을 확인할 수 있다.


#### 3. 행동적 모델링(Behavioral Modeling) 실습
```verilog title:"Half Adder_Behavioral"
module half_adder_behavioral(
    input A, B,
    output reg sum, carry
    );
    always @(A, B)begin
        case( {A, B} )
            2'b00: begin sum = 0; carry = 0; end
            2'b01: begin sum = 1; carry = 0; end
            2'b10: begin sum = 1; carry = 0; end
            2'b11: begin sum = 0; carry = 1; end
        endcase
    end
endmodule
```
위의 코드는 반가산기를 행동적 모델링으로 구현한 모습이다.

행동적 모델링은 이름 그대로 "회로가 어떤 기능을 하는지" 에 집중하는 모델링 기법이다.
내부 구조에 대한 직접적인 언급 없이 알고리즘으로 구현하는 것이 특징이다.
이를 위해 C언어와 비슷하게 if, case, for 등과 같은 조건문을 사용한다.

![[Pasted image 20250629173808.png]]
행동적 모델링으로 하드웨어를 설계한 후 Schematic을 보면 Structural과 다르게 멀티플렉서를 사용한 회로가 생성이 된 것을 확인할 수 있다.


#### 4. 데이터플로우 모델링 실습
```verilog title:"Half Adder_Dataflow"
module half_adder_dataflow(
    input A, B,
    output sum, carry    
    );
    
    wire [ 1:0 ] sum_value;
    
    assign sum_value = A + B;
    assign sum = sum_value[0];
    assign carry = sum_value[1];
endmodule
```
위의 코드는 반가산기를 데이터플로우 모델링으로 구현한 모습이다.

데이터플로우 모델링은 데이터가 회로 내에서 어떻게 흐르는지 수식, 연산자로 정의하는 모델링 기법이다.
"특정 입력에 따라 출력이 어떻게 되는가" 에 집중한 모델링 방식. 이를 위해 assign 문을 사용한다.