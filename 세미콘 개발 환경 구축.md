우분투 최신 버전(25.04) 사용 중 자잘한 버그와 충돌이 너무 많아 LTS 버전으로 회귀하는 김에 셋업 일지를 작성.


[타 저장소 자동 마운트](https://m.blog.naver.com/watney0813/221017927194)
# 1. 우분투 첫 사용시

1. 본인이 프로그램을 이것저것 뜯어보는게 좋아서 미치겠다 하는게 아니면 우분투 LTS 버전 사용을 권장.
2. 어플리케이션 설치 시 SNAP 패키지는 경험상 오류가 많았음. 선택이 가능하면 데비안 패키지 사용 추천.



# 2. Vivado/Vitis 설치

[AMD 공식 문서 참조](https://docs.amd.com/r/en-US/ug1400-vitis-embedded/Installing-the-Vitis-Software-Platform)

## 1. 선행 라이브러리 설치
![[Images/Pasted image 20250904222527.png]]
설치 툴을 이용해 모든 설치가 끝났으면, 비바도 혹은 바이티스 설치 경로에서 scripts 폴더 내 installLibs.sh 셸 파일을 실행해 프로그램에 필요한 라이브러리를 설치한다.

```bash title="설치 명령어"
cd /비바도or바이티스 폴더/scripts
sudo ./installLibs.sh
```


## 2. 케이블 드라이버 설치
![[Images/Pasted image 20250904223302.png]]
위 사진에 나온 것 처럼 비바도/바이티스 경로 내 /data/xicom/cable_drivers/lin64/install_script/install_drivers 에서 드라이버 설치를 진행한다.

```bash title="설치 명령어"
sudo ./install_drivers
sudo ./install_digilent.sh
```







# 3. cubeIDE(STM) 설치

[공홈 설치 링크](https://www.st.com/en/development-tools/stm32cubeide.html)
위 링크에서 데비안 패키지 설치 파일을 다운로드 후 압축 해제.
압축을 해제하면 shell 파일(.sh)이 나오는데, 이것을 설치한다.
파일 이름이 상당히 기니 stm.sh 등 간단한 이름으로 바꾸고 시작하는 것을 추천한다.
```bash title="설치 명령어"
sudo chmod 777 stm.sh
sudo ./stm.sh
```

![[Images/Pasted image 20250904231202.png]]

해당 명령어로 설치를 진행하면 맨 처음에 약관이 나오는데, 키보드의 페이지 다운 버튼을 여러번 눌러 내려간 후 Y를 입력해 모두 동의한다. 
그 이후에도 추가 프로그램(디버그 관련) 설치 및 동의 등 여부를 물어보는데, 마찬가지로 모두 y로 설치하면 된다.


# 4. vsCode 설치 및 AVR 개발환경 만들기

[공홈 설치링크](https://code.visualstudio.com/)

우분투의 App Center에서도 다운로드 받을 수 있지만, SNAP 패키지로 받았을 때 한글 관련 버그가 있다는 제보가 많으니 공홈에서 Debian 패키지로 다운로드 받도록 한다.(본인도 갑자기 걸린 버그임)

## 1. vsCode 설치

```bash title="설치 명령어"
sudo apt install ./code어쩌구저쩌구.deb
```

## 2. AVR 관련 선행 프로그램 설치

[Microchip 공홈](https://www.microchip.com/en-us/tools-resources/develop/microchip-studio/gcc-compilers)

![[Images/Pasted image 20250904233554.png]]
Microchip 홈페이지에서 AVR Toolchain을 설치한다.
리눅스 OS에 ATmega128a(8비트)를 사용할 예정이니 8비트 툴체인을 받아 준다.
설치 후 압축 해제한 폴더는 이후에 vsCode에서 사용해야 하니 찾을 수 있는 경로에 넣어준다.

```bash title="설치 명령어"
sudo apt install cmake
```
위의 명령어로 cmake를 설치해 준다.

## 3. vsCode 설정


### 1. 확장기능 설치

![[Images/Pasted image 20250904234733.png]]
vsCode 좌측 탭에서 Extension 탭을 찾아 사진에 나온 확장기능 중 Github 관련 제외 모두 설치한다.
 
### 2. AVR 컴파일, 디버깅 환경 구축

#### 1. Cmake Tools 설정

![[Images/Pasted image 20250904234031.png]]
vsCode 좌상단 File 탭을 클릭해 워크스페이스를 만들거나 이미 있는 폴더를 설정해 준다.


![[Images/Pasted image 20250904235341.png]]
그 후 Extension에서 Cmake Tools에 우클릭 후 설정에 들어간다.

![[Images/Pasted image 20250904235444.png]]
설정 중 Configure Args에 Add item을 클릭한다.

![[Images/Pasted image 20250904235620.png]]
그 후 [[#2. AVR 관련 선행 프로그램 설치|위에서 설치했던]] AVR Toolchain의 경로를 입력해 준다.

```
-DAVR_TOOLCHAIN_DIR=/TOOLCHAIN경로
```


Toolchain의 경로를 입력했으면 Cmake의 경로 또한 추가해 준다.
```bash title="경로 찾기 명령어"
sudo which make
```
위의 명령어로 cmake가 설치된 경로를 찾은 후


![[Images/Pasted image 20250905001109.png]]
```
-DCMAKE_MAKE_PROGRAM=/cmake경로
```
위와 같이 총 2개의 경로를 추가해 준다.


![[Images/Pasted image 20250905001303.png]]
그 후 밑에서 Generator 설정 칸에 "Unix Makefiles"를 입력한다.



#### 2. Cmake 설정파일 만들기

![[Images/Pasted image 20250905001524.png]]
워크스페이스 내부에 tools 폴더를 만들고 그 폴더에 avr-gcc.cmake라는 파일을 생성한다.

```cmake title="avr-gcc.cmake"
# CMake 프로젝트에 AVR 플랫폼 설정
set(CMAKE_SYSTEM_NAME Generic) # 시스템 이름을 'Generic'(범용)으로 설정
set(CMAKE_SYSTEM_PROCESSOR AVR) # 프로세서를 AVR 마이크로컨트롤러로 설정

  

# 타겟 MCU 설정 (2025.04.30 수정 사항)
set(MCU atmega128a) # 사용할 마이크로컨트롤러를 ATmega128A로 설정
set(CMAKE_C_FLAGS "-mmcu=${MCU}") # MCU 설정
set(CMAKE_CXX_FLAGS "-mmcu=${MCU}") # C++ 컴파일러에 MCU 설정 플래그 전달

  

# AVR Toolchain 경로 설정
set(BINUTILS_PATH ${AVR_TOOLCHAIN_DIR}) # AVR 도구체인 루트 디렉토리 지정

  

# AVR Toolchain 실행 파일 경로 설정
set(TOOLCHAIN_PREFIX ${AVR_TOOLCHAIN_DIR}/bin/avr-) # AVR 컴파일러 및 유틸리티 파일 경로 접두사 설정

  

# CMake 테스트 빌드 대상 유형 설정
set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY) # CMake의 테스트 컴파일을 정적 라이브러리로 제한

  

# 컴파일러 경로 설정
set(CMAKE_C_COMPILER "${TOOLCHAIN_PREFIX}gcc" CACHE FILEPATH "C Compiler path") # C 컴파일러 경로
set(CMAKE_ASM_COMPILER ${CMAKE_C_COMPILER}) # ASM(어셈블리) 컴파일러를 C 컴파일러와 동일하게 설정
set(CMAKE_CXX_COMPILER "${TOOLCHAIN_PREFIX}g++" CACHE FILEPATH "C++ Compiler path") # C++ 컴파일러 경로

  

# AVR에서 사용하는 추가 유틸리티 경로 설정
set(CMAKE_OBJCOPY ${TOOLCHAIN_PREFIX}objcopy CACHE INTERNAL "objcopy tool") # 바이너리 변환 유틸리티 설정
set(CMAKE_SIZE_UTIL ${TOOLCHAIN_PREFIX}size CACHE INTERNAL "size tool") # 바이너리 크기 확인 유틸리티 설정

  

# C/C++ 표준 버전 설정
set(CMAKE_C_STANDARD 11) # C 언어 표준을 C11로 설정
set(CMAKE_CXX_STANDARD 11) # C++ 언어 표준을 C++11로 설정

  

# 컴파일러 확인 단계 비활성화
set(CMAKE_C_COMPILER_FORCED TRUE) # C 컴파일러 강제 사용 (검사 생략)
set(CMAKE_CXX_COMPILER_FORCED TRUE) # C++ 컴파일러 강제 사용 (검사 생략)

  

# 컴파일 및 링크 시 사용할 검색 경로 설정
set(CMAKE_FIND_ROOT_PATH ${BINUTILS_PATH}) # 검색 루트 경로를 도구체인 경로로 설정
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) # 프로그램 검색 시 루트 경로 사용 안 함
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY) # 라이브러리 검색 시 루트 경로만 사용
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) # 헤더 파일 검색 시 루트 경로만 사용
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY) # 패키지 검색 시 루트 경로만 사용
```
위의 코드를 복사 후 방금 만든 cmake 파일에 붙여넣기 한다.


![[Images/Pasted image 20250905001857.png]]
워크스페이스 내부에 .vscode 폴더를 만든 후 내부에 cmake-kits.jason 파일을 생성한다.

```json title:"cmake-kits.jason"
[
	{
		"name": "AVR-GCC Embedded",
		"toolchainFile": "${workspaceFolder}/tools/avr-gcc.cmake"
	}
]
```
위의 코드를 복사해서 방금 만든 파일에 붙여넣는다.


![[Images/Pasted image 20250905002742.png]]
vsCode에서 f1키를 눌러 커맨드 창을 띄우고, "CMake: Configure" 커맨드를 찾아 실행한다.





# 5. WINE 및 카카오톡 설치

## 1. 
사용 중인 OS의 아키텍쳐가 64비트 기반이면 32비트 아키텍쳐를 활성화해 준다.
```bash title="설치 명령어"
sudo dpkg --add-architecture i386
sudo mkdir -pm755 /etc/apt/keyrings
```
keyrings 폴더가 이미 해당 디렉토리에 있을 경우 2번 줄 명령어는 생략 가능.


```bash title="키 로드"
wget -O - https://dl.winehq.org/wine-builds/winehq.key | sudo gpg --dearmor -o /etc/apt/keyrings/winehq-archive.key -
```
위의 명령어로 방금 만든 폴더에 키값을 가져온다.

![[Images/Pasted image 20250905003946.png]]
이런 응답이 나오면 성공한 것.



| **plucky**  <br>Ubuntu 25.04                     | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/ubuntu/dists/plucky/winehq-plucky.sources```     |
| ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| **noble**  <br>Ubuntu 24.04  <br>Linux Mint 22   | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/ubuntu/dists/noble/winehq-noble.sources```       |
| **jammy**  <br>Ubuntu 22.04  <br>Linux Mint 21.x | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/ubuntu/dists/focal/winehq-focal.sources```       |
| **forky**  <br>Debian Testing                    | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/debian/dists/forky/winehq-forky.sources```       |
| **trixie**  <br>Debian 13                        | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/debian/dists/trixie/winehq-trixie.sources```     |
| **bookworm**  <br>Debian 12                      | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/debian/dists/bookworm/winehq-bookworm.sources``` |
위의 표에서 본인이 해당되는 OS에 맞는 명령어를 사용해 리포를 지정해 준다.
그 후 ``sudo apt update`` 명령어를 이용해 방금 추가한 리포에서 파일을 받아준다. 


```bash title="설치 명령어"
sudo apt install --install-recommends winehq-stable
wine --version
```
리포에서 파일을 받았으면 위의 명령어를 통해 와인을 설치한다.
설치가 끝났으면 ``wine --version`` 혹은 ``which wine`` 등의 명령어로 제대로 설치가 됐는지 확인할수 있다. 