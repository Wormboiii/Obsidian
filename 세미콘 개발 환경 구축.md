우분투 최신 버전(25.04) 사용 중 자잘한 버그와 충돌이 너무 많아 LTS 버전으로 회귀하는 김에 셋업 일지를 작성. 이 문서는 우분투 24.04.3 LTS 버전과 윈도우 11 버전에 기반해 작성하였음.

# **0. 목차**

- ##  [[#**1. 문서 수정 내역**| 1. 문서 수정 내역]]


- ## [[#**2. 우분투 첫 사용시**|2. 우분투 첫 사용시]]


- ## [[#**3. Vivado/Vitis 설치**|3. Viavado/Vitis 설치]]
	- ### [[#**1. 선행 라이브러리 설치**|1. 선행 라이브러리 설치]]
	- ### [[#**2. 케이블 드라이버 설치**|2. 케이블 드라이버 설치]]


- ## [[#**4. cubeIDE(STM) 설치**|4. cubeIDE 설치]]


- ## [[#**5. vsCode 설치 및 AVR 개발환경 만들기**|5. vsCode 설치 및 AVR 개발환경 만들기]]
	- ### [[#**1. vsCode 설치**|1. vsCode 설치]]
	- ### [[#**2. AVR 관련 선행 프로그램 설치**|2. AVR 관련 선행 프로그램 설치]]
	- ### [[#**3. vsCode 설정**|3. vsCode 설정]]
		- #### [[#**1. 확장기능 설치**|1. 확장기능 설치]]
		- #### [[#**2. AVR 컴파일, 디버깅 환경 구축**|2. AVR 컴파일, 디버깅 환경 구축]]
			- ##### [[#**1. Cmake Tools 설정**|1. Cmake Tools 설정]]
			- ##### [[#**2. Cmake 설정파일 만들기**|2. Cmake 설정파일 만들기]]
			- ##### [[#**3. Cmake Config**|3. Cmake Config]]
			- ##### [[#**4. Build 관련 설정**|4. Build 관련 설정]]
			- ##### [[#**5. Run 관련 설정**|5. Run 관련 설정]]
			- ##### [[#**6. Test Run**|6. Test Run]]
			- ##### [[#**7. 파일 구조 세팅**|7. 파일 구조 세팅]]
			- ##### [[#**8. 파일 구조에 따른 Test Run**|8. 파일 구조에 따른 Test Run]]
			- ##### [[#**9. 사용하면 좋은 Extension**|9. 사용하면 좋은 Extension]]


- ## [[#**6. WINE 및 카카오톡 설치**|6. WINE 및 카카오톡 설치]]
	- ### [[#**1. WINE 설치**|1. WINE 설치]]
	- ### [[#**2. 카카오톡 설치**|2. 카카오톡 설치]]
	- ### [[#**3. explorer.exe 관련 문제**|3. explorer.exe 관련 문제]]


- ## [[#**7. 듀얼부팅 관련 설정들**|7. 듀얼부팅 관련 설정들]]
	- ### [[#**1. 블루투스 키보드 항상 페어링 해야 하는 문제 해결법**|1. 블루투스 키보드 항상 페어링 해야 하는 문제 해결법]]
	- ### [[#**2. 듀얼 부팅 시 윈도우에서 시간 안맞는 문제 해결법**|2. 듀얼 부팅 시 윈도우에서 시간 안맞는 문제 해결법]]


- ## [[#**8. 우분투 관련 설정들**|8. 우분투 관련 설정들]]
	- ### [[#**1. PC 시작 시 백그라운드에 특정 프로그램 자동으로 시작하기**|1. PC 시작 시 백그라운드에 특정 프로그램 자동으로 시작하기]]
	- ### [[#**2. 디스크 자동 마운트**|2. 디스크 자동 마운트]]
	- ### [[#**3. 앱 바로가기에서 실행시 아이콘 불일치**|3. 앱 바로가기에서 실행시 아이콘 불일치]]

***

# **1. 문서 수정 내역**

- 25.09.01 - 문서 첫 생성
- 25.09.05 - 1번~7번 대문단 작성
- 25.09.10 - [[#3. explorer.exe 관련 문제]] 내용 추가, [[#2. AVR 컴파일, 디버깅 환경 구축]] 항목 내용 보완
***


# **2. 우분투 첫 사용시**

1. 본인이 프로그램을 이것저것 뜯어보는게 좋아서 미치겠다 하는게 아니면 우분투 LTS 버전 사용을 권장.
2. 어플리케이션 설치 시 SNAP 패키지는 경험상 오류가 많았음. 선택이 가능하면 데비안 패키지 사용 추천.
***



# **3. Vivado/Vitis 설치**

[공홈 설치 가이드 참조](https://docs.amd.com/r/en-US/ug1400-vitis-embedded/Installing-the-Vitis-Software-Platform)
[공홈 설치 가이드 참조(USB 드라이버)](https://docs.amd.com/r/en-US/ug973-vivado-release-notes-install-license/Installing-Cable-Drivers)

## **1. 선행 라이브러리 설치**
![[Images/Pasted image 20250904222527.png]]
설치 툴을 이용해 모든 설치가 끝났으면, 비바도 혹은 바이티스 설치 경로에서 scripts 폴더 내 installLibs.sh 셸 파일을 실행해 프로그램에 필요한 라이브러리를 설치한다.

```bash title="설치 명령어"
cd /비바도or바이티스 폴더/scripts
sudo ./installLibs.sh
```


## **2. 케이블 드라이버 설치**
![[Images/Pasted image 20250904223302.png]]
위 사진에 나온 것 처럼 비바도/바이티스 경로 내 /data/xicom/cable_drivers/lin64/install_script/install_drivers 에서 드라이버 설치를 진행한다.

```bash title="설치 명령어"
sudo ./install_drivers
sudo ./install_digilent.sh
```





***


# **4. cubeIDE(STM) 설치**

[공홈 설치 링크](https://www.st.com/en/development-tools/stm32cubeide.html)
[공홈 설치 가이드 링크](file:///home/wonhyeok/%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C/um2563-stm32cubeide-installation-guide-stmicroelectronics.pdf)
위 링크에서 데비안 패키지 설치 파일을 다운로드 후 압축 해제.
압축을 해제하면 shell 파일(.sh)이 나오는데, 이것을 설치한다.
파일 이름이 상당히 기니 stm.sh 등 간단한 이름으로 바꾸고 시작하는 것을 추천한다.
```bash title="설치 명령어"
sudo chmod 777 stm.sh
sudo ./stm.sh
```

![[Images/Pasted image 20250904231202.png]]

해당 명령어로 설치를 진행하면 맨 처음에 약관이 나오는데, 키보드의 페이지 다운 버튼을 여러번 눌러 내려간 후 Y를 입력해 모두 동의한다. 
그 이후에도 추가 프로그램(디버그 관련) 설치 및 동의 등 여부를 물어보는데, 마찬가지로 모두 y로 설치하면 된다.

![[Images/Pasted image 20250905132048.png]]
프로그램을 실행 후 상단 Help 탭에서 STM32Cube updates -> Connection to myST에 들어간다.
들어가면 나오는 팝업 창에서 가입한 계정으로 로그인을 해 준다.


![[Images/Pasted image 20250905132343.png]]
그 이후 상단 File 탭에서 New->STM32 Project를 들어가서 새로운 프로젝트를 만들어 준다.


![[Images/Pasted image 20250905132451.png]]
좌측 상단에 내 보드에 있는 칩을 검색 후 리스트에서 선택해 다음으로 넘어간다.
앞으로 자주 쓸 보드이니 별표를 체크해 두는것도 좋다.


![[Images/Pasted image 20250905132606.png]]
그 다음 프로젝트 이름을 입력하고 Next를 클릭한다.


![[Images/Pasted image 20250905132802.png]]
별 다른 설정 없이 Finish를 누른다.

![[Images/Pasted image 20250905132829.png]]
그러면 현재 내 프로젝트에 필요한 패키지를 자동으로 받기 시작한다.
위의 과정 중 MyST에 로그인을 하지 않으면 다운로드를 하지 못하니 주의!
설치가 끝나면 프로그램 사용이 가능하다.
***


# **5. vsCode 설치 및 AVR 개발환경 만들기**

[공홈 설치링크](https://code.visualstudio.com/)

우분투의 App Center에서도 다운로드 받을 수 있지만, SNAP 패키지로 받았을 때 한글 관련 버그가 있다는 제보가 많으니 공홈에서 Debian 패키지로 다운로드 받도록 한다.(본인도 갑자기 걸린 버그임)

## **1. vsCode 설치**

```bash title="설치 명령어"
sudo apt install ./code어쩌구저쩌구.deb
```

## **2. AVR 관련 선행 프로그램 설치**

[Microchip 공홈](https://www.microchip.com/en-us/tools-resources/develop/microchip-studio/gcc-compilers)

![[Images/Pasted image 20250904233554.png]]
Microchip 홈페이지에서 AVR Toolchain을 설치한다.
리눅스 OS에 ATmega128a(8비트)를 사용할 예정이니 8비트 툴체인을 받아 준다.
설치 후 압축 해제한 폴더는 이후에 vsCode에서 사용해야 하니 찾을 수 있는 경로에 넣어준다.

```bash title="설치 명령어"
sudo apt install cmake
sudo apt install make
sudo apt install avrdude
```
위의 명령어로 cmake, make, avrdude를 설치해 준다.

## **3. vsCode 설정**


### **1. 확장기능 설치**

![[Images/Pasted image 20250904234733.png]]
vsCode 좌측 탭에서 Extension 탭을 찾아 사진에 나온 확장기능 중 Github 관련 제외 모두 설치한다.
 
### **2. AVR 컴파일, 디버깅 환경 구축**

#### **1. Cmake Tools 설정**

![[Images/Pasted image 20250904234031.png]]
vsCode 좌상단 File 탭을 클릭해 워크스페이스를 만들거나 이미 있는 폴더를 설정해 준다.


![[Images/Pasted image 20250904235341.png]]
그 후 Extension에서 Cmake Tools에 우클릭 후 설정에 들어간다.

![[Images/Pasted image 20250904235444.png]]
설정 중 Configure Args에 Add item을 클릭한다.

![[Images/Pasted image 20250904235620.png]]
그 후 [[#2. AVR 관련 선행 프로그램 설치|위에서 설치했던]] AVR Toolchain의 경로를 입력해 준다.

```
-DAVR_TOOLCHAIN_DIR=/TOOLCHAIN경로
```


Toolchain의 경로를 입력했으면 Cmake의 경로 또한 추가해 준다.
```bash title="경로 찾기 명령어"
sudo which make
```
위의 명령어로 cmake가 설치된 경로를 찾은 후


![[Images/Pasted image 20250905001109.png]]
```
-DCMAKE_MAKE_PROGRAM=/cmake경로
```
위와 같이 총 2개의 경로를 추가해 준다.


![[Images/Pasted image 20250905001303.png]]
그 후 밑에서 Generator 설정 칸에 "Unix Makefiles"를 입력한다.



#### **2. Cmake 설정파일 만들기**

![[Images/Pasted image 20250905001524.png]]
워크스페이스 내부에 tools 폴더를 만들고 그 폴더에 avr-gcc.cmake라는 파일을 생성한다.

```cmake title="avr-toolchain.cmake"
# CMake 프로젝트에 AVR 플랫폼 설정
set(CMAKE_SYSTEM_NAME Generic) # 시스템 이름을 'Generic'(범용)으로 설정
set(CMAKE_SYSTEM_PROCESSOR AVR) # 프로세서를 AVR 마이크로컨트롤러로 설정

  

# 타겟 MCU 설정 (2025.04.30 수정 사항)
set(MCU atmega128a) # 사용할 마이크로컨트롤러를 ATmega128A로 설정
set(CMAKE_C_FLAGS "-mmcu=${MCU}") # MCU 설정
set(CMAKE_CXX_FLAGS "-mmcu=${MCU}") # C++ 컴파일러에 MCU 설정 플래그 전달

  

# AVR Toolchain 경로 설정
set(BINUTILS_PATH ${AVR_TOOLCHAIN_DIR}) # AVR 도구체인 루트 디렉토리 지정

  

# AVR Toolchain 실행 파일 경로 설정
set(TOOLCHAIN_PREFIX ${AVR_TOOLCHAIN_DIR}/bin/avr-) # AVR 컴파일러 및 유틸리티 파일 경로 접두사 설정

  

# CMake 테스트 빌드 대상 유형 설정
set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY) # CMake의 테스트 컴파일을 정적 라이브러리로 제한

  

# 컴파일러 경로 설정
set(CMAKE_C_COMPILER "${TOOLCHAIN_PREFIX}gcc" CACHE FILEPATH "C Compiler path") # C 컴파일러 경로
set(CMAKE_ASM_COMPILER ${CMAKE_C_COMPILER}) # ASM(어셈블리) 컴파일러를 C 컴파일러와 동일하게 설정
set(CMAKE_CXX_COMPILER "${TOOLCHAIN_PREFIX}g++" CACHE FILEPATH "C++ Compiler path") # C++ 컴파일러 경로

  

# AVR에서 사용하는 추가 유틸리티 경로 설정
set(CMAKE_OBJCOPY ${TOOLCHAIN_PREFIX}objcopy CACHE INTERNAL "objcopy tool") # 바이너리 변환 유틸리티 설정
set(CMAKE_SIZE_UTIL ${TOOLCHAIN_PREFIX}size CACHE INTERNAL "size tool") # 바이너리 크기 확인 유틸리티 설정

  

# C/C++ 표준 버전 설정
set(CMAKE_C_STANDARD 11) # C 언어 표준을 C11로 설정
set(CMAKE_CXX_STANDARD 11) # C++ 언어 표준을 C++11로 설정

  

# 컴파일러 확인 단계 비활성화
set(CMAKE_C_COMPILER_FORCED TRUE) # C 컴파일러 강제 사용 (검사 생략)
set(CMAKE_CXX_COMPILER_FORCED TRUE) # C++ 컴파일러 강제 사용 (검사 생략)

  

# 컴파일 및 링크 시 사용할 검색 경로 설정
set(CMAKE_FIND_ROOT_PATH ${BINUTILS_PATH}) # 검색 루트 경로를 도구체인 경로로 설정
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) # 프로그램 검색 시 루트 경로 사용 안 함
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY) # 라이브러리 검색 시 루트 경로만 사용
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) # 헤더 파일 검색 시 루트 경로만 사용
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY) # 패키지 검색 시 루트 경로만 사용
```
위의 코드를 복사 후 방금 만든 cmake 파일에 붙여넣기 한다.


![[Images/Pasted image 20250905001857.png]]
워크스페이스 내부에 .vscode 폴더를 만든 후 내부에 cmake-kits.jason 파일을 생성한다.

```json title:"cmake-kits.jason"
[
	{
		"name": "AVR-GCC Embedded",
		"toolchainFile": "${workspaceFolder}/tools/avr-gcc.cmake"
	}
]
```
위의 코드를 복사해서 방금 만든 파일에 붙여넣는다.


![[Images/Pasted image 20250905002742.png]]
vsCode에서 f1키를 눌러 커맨드 창을 띄우고, "CMake: Configure" 커맨드를 찾아 실행한다.



#### **3. Cmake Config**

![[Images/Pasted image 20250910150007.png]]
F1을 눌러 CMake: Quick Start를 선택한 후

![[Images/Pasted image 20250910150128.png]]
프로젝트 이름을 입력한다.

![[Images/Pasted image 20250910150159.png]]
C 프로젝트 만들기(Create a C project)를 선택한다.


![[Images/Pasted image 20250910150328.png]]
Executable 선택 후

![[Images/Pasted image 20250910150407.png]]
아무것도 체크하지 않고 esc를 누르거나 ok를 누른다.
이후에 나오는 사전 설정 관련 창도 esc를 눌러 빠져나온다.

#### **4. Build 관련 설정**

![[Images/Pasted image 20250910151700.png]]
다시 F1을 눌러 Cmake: Build를 선택해 파일을 빌드한다.

![[Images/Pasted image 20250910152000.png]]
Build가 완료되면 사진과 같이 구성된다.
이후 CMakeLists.txt 내부 코드를 아래의 내용으로 바꿔 준다.

```cmake title="CMakeLists.txt"
cmake_minimum_required(VERSION 3.10.0)

  
#프로젝트 이름 설정, 내 프로젝트 이름으로 맞춰야 함!!!
project(test
	LANGUAGES ASM C CXX
)
  
set(EXECUTABLE ${PROJECT_NAME}.elf)

# 소스 파일 수집
file(GLOB SRC_FILES CONFIGURE_DEPENDS
	*.c
	*.cpp
) 

file(GLOB_RECURSE SRC_FILES_RECURSE CONFIGURE_DEPENDS
	src/*.c
	src/*.cpp
	src/app/*.c
	src/common/*.c
	src/driver/*.c
) 

# 실행 파일 생성
add_executable(${EXECUTABLE}
	${SRC_FILES}
	${SRC_FILES_RECURSE}
)

# 컴파일 타임 매크로
target_compile_definitions(${EXECUTABLE} PRIVATE
	-DF_CPU=16000000UL
)

# include 디렉토리 설정
target_include_directories(${EXECUTABLE} PRIVATE
	src
	src/app
	# src/bsp
	src/hw
	src/driver
	src/common
	# src/common/hw/include
)

# 컴파일러 옵션
target_compile_options(${EXECUTABLE} PRIVATE
	-fdata-sections
	-ffunction-sections
	-MMD
	-flto
	-fno-fat-lto-objects
	-Wall
	-Os
	-g3
)

# 링커 옵션
target_link_options(${EXECUTABLE} PRIVATE
	-flto
	-fuse-linker-plugin
	-lm
	-Wl,-Map=${CMAKE_BINARY_DIR}/${PROJECT_NAME}.map,--cref
	-Wl,--gc-sections
	-Xlinker -print-memory-usage -Xlinker
)

# 바이너리 파일 생성 (.hex)
add_custom_command(TARGET ${EXECUTABLE}
	POST_BUILD
	COMMAND ${CMAKE_OBJCOPY} -O ihex -R .eeprom ${EXECUTABLE} ${CMAKE_BINARY_DIR}/${PROJECT_NAME}.hex
	COMMENT "Generating HEX file"
)

# EEPROM 파일 생성 (.eep)
add_custom_command(TARGET ${EXECUTABLE}
	POST_BUILD
	COMMAND ${CMAKE_OBJCOPY} -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 ${EXECUTABLE} ${CMAKE_BINARY_DIR}/${PROJECT_NAME}.eep
	COMMENT "Generating EEPROM file"
) 

# 바이너리 사이즈 출력
add_custom_command(TARGET ${EXECUTABLE}
	POST_BUILD
	COMMAND ${CMAKE_SIZE_UTIL} ${EXECUTABLE}
	COMMENT "Firmware Size:"
)
```

![[Images/Pasted image 20250910153153.png]]
.vscode 하위에 c_cpp_properties.json 이라는 파일을 생성해 준 후 아래 코드로 내용을 채워준다.

```json title:"c_cpp_properties.json"
{
    "configurations": [
        {
            "name": "Ubuntu AVR",
            "includePath": [
                "${workspaceFolder}/**",
                "/home/wonhyeok/tools/avr_toolchain/avr/include",
                "/home/wonhyeok/tools/avr_toolchain/avr/include/avr"
            ],
            "defines": [
                "F_CPU=16000000UL",
                "__AVR_ATmega128A__"
            ],
            // "compilerPath": "/usr/bin/gcc",
            "compilerPath": "/home/wonhyeok/tools/avr_toolchain/bin/avr-gcc",
            // "cStandard": "c17",
            "cStandard": "c11",
            // "intelliSenseMode": "linux-gcc-x64",
            "intelliSenseMode": "gcc-x64"
            // "cppStandard": "gnu++17"
        }
    ],
    "version": 4
}
```
이 코드 중 includePath와 compilerPath 등 경로를 설정하는 부분을 본인이 설치한 avr toolchain 경로로 직접 잘 맞추어 주어야 한다.

![[Images/Pasted image 20250910162145.png]]
이후 다시 F1을 누른 후 Reset Cmake Tools Extension State 를 선택하면 컴파일러를 선택하는 창이 나오는데, 이때 AVR-GCC를 선택해 준다.

![[Images/Pasted image 20250910162250.png]]
만약 위의 창이 뜨지 않는다면, F1을 누른 후 CMake: Select a kit을 선택해서 컴파일러를 선택해 준다.


![[Images/Pasted image 20250910153636.png]]
이후 사진과 같이 avr 관련 외부 헤더 파일을 include 했을 때 밑줄이 뜨지 않고 정상적으로 파일을 불러 오는지 확인한다.

#### **5. Run 관련 설정**

터미널 창에
```shell
ls -l /dev/tty*
```
명령어를 통해 현재 USB를 통해 연결된 내 AVR 보드가 몇번 포트를 잡고 있는지 확인한다.

![[Images/Pasted image 20250910154433.png]]

보통 이런 식의 응답이 오는데, ttyUSB0, ttyUSB1 등으로 뜨는 것을 찾으면 된다.
만약 좌측 권한 표시에 w(write, 쓰기) 권한이 보이지 않으면,

```shell
sudo chmod +x /dev/ttyUSB0
```
와 같이 쓰기 권한을 추가한다.


이후 vscode로 돌아가서
![[Images/Pasted image 20250910153911.png]]
'.vscode' 폴더 하위에 tasks.json 이라는 파일을 만든 후 아래 코드로 내용을 채워준다.
```json title:"tasks.json"
{
    "version": "2.0.0",
    "tasks": [
        {
            // CMake를 사용하여 빌드를 수행하는 작업
            "label": "CMake Build",
            "type": "process", // 외부 프로세스를 호출하여 작업을 수행
            "command": "cmake", // CMake 명령어 실행
            "args": [
                "--build", // CMake를 빌드 모드로 실행
                "${workspaceFolder}/build",
                // 작업 공간 폴더 안의 'build' 디렉토리를 대상으로 빌드
                
                "--target", // 특정 빌드 타겟을 지정
                "all" // 모든 타겟을 빌드
            ],
            "group": {
                "kind": "build", // 빌드 작업으로 분류
                "isDefault": true // 기본 빌드 작업으로 설정
            },
            "problemMatcher": [] // 문제 매처를 지정하지 않음
        },
        {
            // CMake를 사용하여 클린(clean)을 수행하는 작업
            "label": "CMake Clean",
            "type": "process", // 외부 프로세스를 호출하여 작업을 수행
            "command": "cmake", // CMake 명령어 실행
            "args": [
                "--build", // CMake를 빌드 모드로 실행
                "${workspaceFolder}/build",
                // 작업 공간 폴더 안의 'build' 디렉토리를 대상으로 실행
                
                "--target", // 특정 빌드 타겟을 지정
                "clean" // 'clean' 타겟을 수행하여 빌드 파일 제거
            ],
            "problemMatcher": [] // 문제 매처를 지정하지 않음
        },
        {
            // avrdude를 사용하여 ATmega128A에 펌웨어를 업로드하는 작업
            "label": "avrdude",
            "type": "shell", // 쉘 명령어 실행
            "command": "/usr/bin/avrdude", // avrdude 명령어 실행
            "args": [
                "-C", "/etc/avrdude.conf", // avrdude 설정 파일 경로
                "-v", // 상세한 출력 활성화
                "-u", // 잠금 비트를 설정하지 않음 (쓰기 보호 해제)
                "-p", "atmega128a", // 타겟 MCU를 ATmega128A로 설정
                "-c", "avrisp2", // 프로그래머 타입을 AVR ISP mkII로 설정
                "-P", "/dev/ttyUSB0", // 프로그래머가 연결된 시리얼 포트 경로 지정
                "-b", "115200", // 통신 속도 설정
                "-U", "flash:w:build/test.hex:i"
                // 플래시에 HEX 파일을 작성(write), 파일 경로 및 형식 지정
            ],
            "problemMatcher": [] // 문제 매처를 지정하지 않음
        }        
    ]
}
```
여기서 args 하위에 -P(포트 지정) 부분을 위에 터미널에서 찾은 부분과 동일한지 확인하고, 다르다면 코드를 수정하여 바꿔 준다.
또한, -U(빌드된 프로그램 저장 경로) 부분도 내 경로에 맞게 수정해 준다.

#### **6. Test Run**

```c title:"main.c"
#include <stdio.h>
#include <avr/io.h>
#include <util/delay.h>

int main(){
	DDRG = 0x01; // G포트 0번을 출력으로 사용

	while(1){
		PORTG = 0x01; // G포트 0번핀에 High 출력(내장 LED와 연결됨, LED On)
		_delay_ms(500); // 0.5초 대기
		PORTG = 0x00; // G포트 0번핀에 Low 출력(LED Off)
		_delay_ms(500);
	}
}
```
위와 같이 main 코드를 수정한 후 상단의 터미널 창을 클릭해 Run Task를 선택한다.

![[Images/Pasted image 20250910163758.png]]

만약 설정이 잘 됐으면 
![[Images/Pasted image 20250910163835.png]]
이 사진처럼 vscode 하단 터미널 창에 프로그램이 잘 들어갔다는 응답이 뜨고, atmega 보드에서는 LED가 깜빡이게 된다.

만약 프로그램이 오류 없이 잘 들어가지만, LED가 깜빡이지 않는 경우 
'tasks.json' 파일이나 'c_cpp_properties.json'과 같은 파일에 경로 등이 올바른지 다시 확인해 본다.

#### **7. 파일 구조 세팅**

파일 분할을 위해 깔끔한 구조를 만들면 코드 유지보수에 도움이 된다.
추후 SoC 등을 할 때도 컴파일러(혹은 IDE)가 유사한 파일 구조를 만들어 주기 때문에, 이 구조에 익숙해 지는것이 좋다.

![[Images/Pasted image 20250910164708.png]]
워크스페이스 하위에 'src'(소스) 폴더를 생성해 준다.

![[Images/Pasted image 20250910164806.png]]
소스 폴더 하위에 'app', 'common', 'driver' 라는 폴더를 생성한다.

![[Images/Pasted image 20250910165036.png]]
생성한 app 폴더 하위에 'app.c' 와 'app.h' 파일을 생성해 주고

```c title:"app.c"
#include "app.h"

void app_init() {

}

void app_main() {

}
```

```c title:"app.h"
#ifndef __APP_H__
#define __APP_H__

#include "../common/def.h"

void app_init();
void app_main();

#endif /* __APP_H__ */
```
위와 같이 내용을 채워 준다.

이후 main.c 파일 내부를
```c title:"main.c"
#include "src/app/app.h"

int main() {
	app_init();
	app_main();
  
	while(1) {
	
	}
}
```
위의 코드만 넣고 나머지는 다 지워준다.


![[Images/Pasted image 20250910165522.png]]
'common' 폴더 내부에 def.h 라는 파일을 생성해 주고

```c title:"def.h"
#ifndef __DEF_H__
#define __DEF_H__

#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>

#endif /* __DEF_H__ */
```
위와 같은 내용으로 코드를 채워 준다.
이 란에는 공통으로 들어가는 헤더 파일들을 include 해 주면 된다.
추후에 추가해야 하는 헤더 파일들도 이 쪽에서 관리해 주면 좋다.

'driver' 폴더 내부에는 추후에 외부(혹은 직접 만든) 소스, 헤더 파일을 넣어서 관리한다.
![[Images/Pasted image 20250910171427.png]]
결과적으로 파일 구조는 이런 식으로 관리하게 된다.

#### **8. 파일 구조에 따른 Test Run**

이제 실제 코드는 app.c에서 짜게 된다.
[[#6. Test Run]] 에서 진행한 코드를 토대로

```c title:"app.c"
#include "app.h"

void app_init() {

}

void app_main() {
	DDRG = 0x01;
	while(1){
		PORTG = 0x01;
		_delay_ms(500);
		PORTG = 0x00;
		_delay_ms(500);
	}
}
```
'app.c'에 이런 코드를 작성한 후 순서대로 build, run을 해보면 아까와 같이 LED가 깜빡이게 된다.

#### **9. 사용하면 좋은 Extension**
##### **1. vscode-icons**
![[Images/Pasted image 20250910172006.png]]
이 추가기능을 설치하면 vscode에서 파일 유형을 감지해 자동으로 그에 맞는 아이콘을 파일명 옆에 띄워준다.

##### **2. Task Explorer**

![[Images/Pasted image 20250910172128.png]]
이 추가기능을 설치하면 build, run 등을 터미널에서 하지 않고 좌측 탭에서 빠르게 접근할 수 있다.

![[Images/Pasted image 20250910174305.png]]
vscode 좌하단 탭을 보면 Task Explorer라는 창이 뜨는데, 이를 이용해 터미널을 사용하지 않고도 build, run 등을 빠르게 할 수 있다.
***




# **6. WINE 및 카카오톡 설치**

카카오톡은 정식으로 리눅스를 지원하지 않는다. 때문에 우분투에서 카톡을 사용하려면 에뮬레이터 프로그램 등을 사용해야 하는데, 가장 대중적인 프로그램이 WINE이다.
## **1. WINE 설치**

사용 중인 OS의 아키텍쳐가 64비트 기반이면 32비트 아키텍쳐를 활성화해 준다.
```bash title="설치 명령어"
sudo dpkg --add-architecture i386
sudo mkdir -pm755 /etc/apt/keyrings
```
keyrings 폴더가 이미 해당 디렉토리에 있을 경우 2번 줄 명령어는 생략 가능.


```bash title="키 로드"
wget -O - https://dl.winehq.org/wine-builds/winehq.key | sudo gpg --dearmor -o /etc/apt/keyrings/winehq-archive.key -
```
위의 명령어로 방금 만든 폴더에 키값을 가져온다.

![[Images/Pasted image 20250905003946.png]]
이런 응답이 나오면 성공한 것.



| **plucky**  <br>Ubuntu 25.04                     | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/ubuntu/dists/plucky/winehq-plucky.sources```     |
| ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| **noble**  <br>Ubuntu 24.04  <br>Linux Mint 22   | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/ubuntu/dists/noble/winehq-noble.sources```       |
| **jammy**  <br>Ubuntu 22.04  <br>Linux Mint 21.x | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/ubuntu/dists/focal/winehq-focal.sources```       |
| **forky**  <br>Debian Testing                    | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/debian/dists/forky/winehq-forky.sources```       |
| **trixie**  <br>Debian 13                        | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/debian/dists/trixie/winehq-trixie.sources```     |
| **bookworm**  <br>Debian 12                      | ```sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/debian/dists/bookworm/winehq-bookworm.sources``` |
위의 표에서 본인이 해당되는 OS에 맞는 명령어를 사용해 리포를 지정해 준다.
그 후 ``sudo apt update`` 명령어를 이용해 방금 추가한 리포에서 파일을 받아준다. 


```bash title="설치 명령어"
sudo apt install --install-recommends winehq-stable
wine --version
```
리포에서 파일을 받았으면 위의 명령어를 통해 와인을 설치한다.
설치가 끝났으면 ``wine --version`` 혹은 ``which wine`` 등의 명령어로 제대로 설치가 됐는지 확인할수 있다. 

[WINE 모노 설치 링크](https://gitlab.winehq.org/mono/wine-mono/-/releases)
원래는 .netframework 기반으로 작동하는 프로그램을 돌리려면 WINE mono를 추가로 설치해 줘야 하지만, 처음 WINE 구동시 mono가 없으니 설치하겠냐고 물어보니 그때 설치하면 된다.

## **2.  카카오톡 설치**

[카톡 공홈 설치 링크](https://www.kakaocorp.com/page/service/service/KakaoTalk)

와인을 설치했으면 공홈 링크에서 설치 파일을 받고 실행한다.
설치 후 카카오톡을 실행해 보면 원래는 한글 폰트가 없어서 ㅁㅁㅁ 이렇게 떠야 하지만, 어째서인지 앱 내부는 괜찮다...?

![[Images/Pasted image 20250905010503.png]]
하지만 앱 내부는 괜찮아도 백그라운드는 여전히 ㅁㅁㅁ로 폰트가 깨져 보인다.
이를 해결하기 위해 wine 경로 내에 한글 폰트를 추가해 줘야 한다.

경로는 보통 아래와 같다.
/home/(사용자명)/.wine/drive_c/windows/Fonts

[굴림체 다운로드 링크](https://macsplex.com/Wdisplay/9776)
위에서 .ttc 확장자의 굴림체를 다운로드한 후 Fonts 폴더에 넣는다.

![[Images/Pasted image 20250905011733.png]]
그 후 ~/.wine 폴더 내에 system.reg 레지스트리 파일을 메모장으로 열어서 MS Shell Dlg를 검색한다.
나온 두가지 모두 Gulim으로 변경해준다.

![[Images/Pasted image 20250905011845.png]]
그 이후 카카오톡을 재시작하면 변경된 것을 확인할 수 있다.

## **3. explorer.exe 관련 문제**

우분투 24.04 LTS, WINE 10 버전에서 PC 화면이 꺼질 때(로그오프를 하지 않고 화면만 꺼질 때도) 빈 창과 함께 explorer.exe라는 프로세스가 뜨는 문제가 있다.

이 때 우분투 상단 시스템 트레이에 있는 카카오톡도 좌클릭, 우클릭 등을 해도 반응이 없이 먹통이 되는데, indicator 관련 문제로 보인다.
최신 우분투(25.04) 버전을 사용할 때는 없던 문제로, 최신 버전에는 픽스가 되었으나 LTS에서는 해결되지 않은 것으로 보인다.
***


# **7. 듀얼부팅 관련 설정들**

## **1. 블루투스 키보드 항상 페어링 해야 하는 문제 해결법**

로지텍 K380 키보드를 사용 중인데, 멀티 페어링을 지원하는 키보드인데도 듀얼OS 환경에서 각 프로파일에 따로 연결이 안됨. 무조건 다른 OS로 넘어갈 때 마다 새로 페어링을 해 주어야 하는 아주 귀찮은 문제 발생.

[해결법 링크](https://hallymer.github.io/etc/2021/02/23/Multiboot-bluetooth-keyboard-connecting-post.html)

맨 처음엔 우분투에서 chntpw 프로그램을 이용해 레지스트리 값을 읽어오는 방식을 시도했지만, BLE가 아닌 BR/EDR 제품군은 키값을 읽지 못함. 위 링크처럼 윈도우 psexec.exe 프로그램을 이용해 키값을 받아옴.

시작하기 전에 앞서 우분투에 블루투스 기기를 먼저 페어링한 후 그 다음에 윈도우에서 페어링을 다시 하고 하단의 조치를 취하면 된다.
### 1. PSEXEC.EXE 설치

[PSTools 링크](https://learn.microsoft.com/ko-kr/sysinternals/downloads/psexec)
위 링크에서 pstools를 다운로드 한 후 'psexec.exe' 만 압축을 해제해 줌.

### 2. 윈도우에서 키값 받아오기

윈도우에서 powershell을 관리자 권한으로 실행 후, psexec.exe 파일을 압축해제한 경로까지 이동.

`.\psexec.exe -s -i regedit /e C:\BTKeys.reg HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\BTHPORT\Parameters\Keys`

위의 명령어를 이용해 C드라이브에 블루투스 키값에 대한 레지스트리를 따 온다.
경로 중 'ControlSet001' 의 숫자가 001이 아닌 다른 숫자일 수도 있다고 하는데, 직접 확인하는 수밖에 없을 것 같다.
"regedit exited with error code 0" 라는 에러 코드가 뜨는데, 리턴값(0)을 받았다는 뜻으로 에러가 아닌 정상 작동을 했다는 뜻이다.

C 드라이브에 가 보면
```shell title:"BTKeys.reg"
Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\BTHPORT\Parameters\Keys]

[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\BTHPORT\Parameters\Keys\c03532490bd8]
"CentralIRK"=hex:2d,81,15,85,3f,46,fd,1c,b7,7b,b7,9b,7f,c6,bb,78
"646d2fa6f0a2"=hex:14,2c,ea,41,f1,b1,96,4b,1f,af,d7,fb,ff,c0,20,7f
"f47335531d7b"=hex:55,e3,12,bd,bc,40,30,de,63,c0,aa,9f,3a,f6,2c,dc

[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\BTHPORT\Parameters\Keys\c03532490bd8\599ddd55480c]
"LTK"=hex:41,ec,d0,a0,cf,2c,09,85,b3,c3,a9,48,dc,5c,21,35
"KeyLength"=dword:00000010
"ERand"=hex(b):00,00,00,00,00,00,00,00
"EDIV"=dword:00000000
"IRK"=hex:3e,0c,5b,63,3e,b5,0b,91,48,ce,bf,e0,4e,86,cd,dc
"Address"=hex(b):a2,f0,a6,2f,6d,64,00,00
"AddressType"=dword:00000000
"CEntralIRKStatus"=dword:00000001
"AuthReq"=dword:0000002d
```
이런 레지스트리 파일이 생성된 것을 확인할 수 있다.

`.\psexec.exe -s -i regedit` 명령어를 사용해 레지스트리 편집기를 실행한 후
`HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\BTHPORT\Parameters\Keys`
위의 경로로 가면,

![[../Images/KakaoTalk_20250814_235608002.jpg]]
이런 화면이 뜨는데, 이 화면에서도 필요한 정보를 모두 얻을 수 있다.
빨간색 부분이 내 PC의 블루투스 MAC 주소이고, 녹색 부분이 내 주변기기(K380 키보드)의 MAC 주소이다.
파란색 밑줄 부분은 내 해당 주변기기의 연결 키 값이다.

### 3. 우분투에서 블루투스 INFO 수정

위의 키값들을 모두 저장했으면 우분투로 넘어온다.
`/var/lib/bluetooth` 경로로 가면 내 PC의 블루투스 맥 주소가 나오는데, 그 폴더까지 들어간다.
그 하위 폴더에는 여러 폴더들이 있을 수 있는데, 그 중 윈도우에서 찾은 내 주변기기의 주소와 이름이 거의 동일하거나 아예 같은 폴더에 들어간다.
인터넷에 다른 사람들은 모두 맥 주소 중 뒷 자리 1~2개만 제외하고 전부 동일하게 뜨는 패턴이 있었는데, 나는 아예 동일하게 떴다.

폴더에 들어가면 info라는 파일이 있는데, 텍스트 편집기로 열어주면
![[../Images/Pasted image 20250815000501.png]]
이렇게 창이 뜬다.
맥 주소를 보고 내가 설정하려고 하는 주변기기인지 아닌지 모른다면, 아무 폴더나 들어가서 info 파일을 열어보면 위의 사진처럼 기기의 이름이 뜨기 때문에 이 이름을 보고 특정하면 된다.

만약 나처럼 맥 주소는 동일하게 뜬다면, LinkKey 하위의 Key값을 위에서 얻은 키값으로 바꿔주면 된다.
레지스트리 편집기 캡쳐 사진 기준 파란색 밑줄 부분, BTKeys.reg 파일 기준`"주변기기 맥 주소"=hex:키값`
이런 패턴으로 있는 키값을 찾아서 바꿔주면 된다.

키값은 위의 캡쳐 사진처럼 모두 대문자로, 콤마나 콜론 없이 이어서 작성하면 된다.
수정을 완료했으면 `sudo service bluetooth restart` 명령어로 블루투스를 재시작 해주면 적용이 된다.

## **2. 듀얼 부팅 시 윈도우에서 시간 안맞는 문제 해결법**

[참고 링크](https://mesnotes.tistory.com/11)

우분투, 윈도우 듀얼 부팅 시 윈도우에서 시간이 안 맞는 문제 발생.
우분투가 메인보드에 덮어쓰는 시간이 한국 시간이 아니여서 윈도우 부팅 시 그 시간을 가져오기 때문에 발생하는 문제.

우분투 터미널에서
```shell
timedatectl set-local-rtc 1 --adjust-system-clock
```
을 입력하면 우분투가 로컬 타임을 메인보드에 저장하게 된다.

제대로 적용되었는지 확인하려면
```shell
timedatectl
```
명령어를 이용해

![[Images/Pasted image 20250907204207.png]]
RTC in local TZ 응답이 Yes로 나오는지 확인한다.
***

# **8. 우분투 관련 설정들**

## **1. PC 시작 시 백그라운드에 특정 프로그램 자동으로 시작하기**

윈도우의 시작 프로그램과 비슷하게 우분투에서도 시작 서비스가 있다.
어떤 프로그램들은 설정에 시작 서비스를 지원하지만, 실제로 적용되지 않는 것들이 많다.

![[Images/Pasted image 20250908173313.png]]
디스코드를 예로 들면, GUI 내부 설정창에도 관련 설정이 있지만, 체크가 되어 있어도 실제로 적용되진 않는다.


![[Images/Pasted image 20250908173630.png]]
이를 해결하기 위해 우분투의 Startup Applications 앱을 실행한다.

![[Images/Pasted image 20250908173722.png]]
실행하면 이런 식으로 시작 프로그램으로 설정이 된 프로필들이 목록으로 나온다.
이 창에서 우측 추가 탭을 누른 후

![[Images/Pasted image 20250908173818.png]]
사진과 같이 Name 란에는 목록에 보일 이름을 쓰고, Comment란에는 목록에 보일 설명을 작성한다.
Command란이 실제 실행할 프로그램 명령어를 적는 칸이다.

### **1. 시작하자마자 특정 프로그램을 띄우고 싶은 경우**

이 경우는 간단히 해당 프로그램 시작 명령어를 작성하면 된다.
(보통 which discord, discord --version 등과 같이 터미널에서 사용하는 명령어)

예를 들어, 컴퓨터를 켜자 마자 디스코드를 바로 띄우고 싶은 경우는
Command 라인에 'discord' 라고만 적어주면 된다.

### **2. 새 창을 띄우지 않고 백그라운드로 돌아가게 하고 싶은 경우**

이 경우는
1. 프로그램 자체가 백그라운드 기능이 있어야 함.
2. 백그라운드로 시작하는 명령어를 직접 찾아야 함.

두 가지의 조건이 필요하다.

![[Images/Pasted image 20250908174532.png]]
첫째로 카카오톡, 디스코드 등 처럼 시스템 트레이에 머물러 있는 기능을 native하게 지원해야 한다.
그리고 그 기능을 사용하는 명령어를 직접 찾아봐야 한다.

명령어는 터미널에서 ``프로세스명 --help`` 와 같이 도움말을 보고 찾아보거나, 구글링을 통해 찾아야 한다.

예시로 든 디스코드의 경우 커맨드 라인에 ``discord --start-minimized`` 라고 작성하면 된다.

## **2. 디스크 자동 마운트**

[타 저장소 자동 마운트](https://m.blog.naver.com/watney0813/221017927194)

나의 경우 노트북에 2개의 내장 SSD가 있고, 용량 압박을 느껴 우분투가 설치된 SSD와 다른 디스크에 자일링스 관련 프로그램을 설치했다.

비바도와 바이티스를 다른 디스크에 설치했다 보니 프로그램을 시작하기 전 수동으로 디스크를 마운트 해 주는것이 귀찮아서 위의 링크를 참고해 디스크를 자동 마운트하게 했다.

## **3. 앱 바로가기에서 실행시 아이콘 불일치**

우분투에서 어플리케이션을 설치 후 GNOME Dock에 넣어두면 바로가기처럼 편하게 접근할 수 있다.
그런데, 몇몇 앱은 바로가기 아이콘과 실제로 실행되는 앱이 일치하지 않고 새 창으로 뜬다.

![[../Images/ㅇㅇㅇ.png]]
이렇게 분명 다른 앱들은 실행하면 아이콘 좌측에 붉은 점으로 떠 있는 서비스 개수가 뜨면서 잘 정렬이 되는데
CubeIDE같은 특정 프로그램은 아이콘을 눌러 실행하면 다른 이름을 가진 서비스가 새 창으로 시작된다.


이는 StartupWMClass가 일치하지 않아서 발생하는 문제로, 해당 앱을 실행하는 .desktop 파일을 수정해 해결할 수 있다.

### **1. 실제 WMClass 확인**

먼저 수정하고자 하는 앱을 실행한 후, 리눅스 터미널도 실행해 
```bash
xprop | grep WM_CLASS
```
위의 명령어를 입력한다. 이 명령어를 입력한 후 미리 켜 놨던 수정하고자 하는 앱 창을 띄워 보면 마우스 커서가 십자 조준선 모양으로 변경되는데, 이 때 앱 화면의 아무 곳이나 클릭한다.


![[../Images/Pasted image 20250907211628.png]]
클릭하면 위의 사진처럼 해당 앱의 실제 WMClass가 응답으로 나온다.


### **2. .desktop 파일 수정**

이후 바로가기 파일인 .desktop 파일을 수정하면 되는데, 일반적으로 아래의 디렉토리 중 하나에 위치해 있다.

```shell
#시스템 전체
usr/share/applications/

#사용자별
~/.local/share/applications/

#Flatpak 패키지
/var/lib/flatpak/exports/share/applications/

#Snap 패키지
/var/lib/snapd/desktop/applications/
```
예시에 사용한 CubeIDE는 전체 사용자용 디렉토리에 위치해 있었다.

위의 디렉토리를 찾아서 내가 수정하고자 하는 앱 아이콘 위에 커서를 대면 뜨는 이름을 찾으면 된다.
만약 비슷한 이름만 있고 똑같은 이름인 .desktop 파일이 없으면 파일을 텍스트 편집기로 열어서
```shell title:"st-stm32cubeide-1.19.0.desktop"
[Desktop Entry]
Name=STMicroelectronics STM32CubeIDE 1.19.0
Comment=STMicroelectronics STM32CubeIDE 1.19.0
GenericName=STM32CubeIDE
Exec=/opt/st/stm32cubeide_1.19.0/stm32cubeide_wayland %F
Icon=/opt/st/stm32cubeide_1.19.0/icon.xpm
Path=/opt/st/stm32cubeide_1.19.0/
Terminal=false
StartupNotify=true
Type=Application
Categories=Development
```
Name 란을 확인해 보면 된다.

해당하는 .desktop 파일을 찾았으면 마찬가지로 텍스트 편집기로 열어서
```shell title:"st-stm32cubeide-1.19.0.desktop"
[Desktop Entry]
Name=STM32CubeIDE 1.19.0
Comment=STMicroelectronics STM32CubeIDE 1.19.0
GenericName=STM32CubeIDE
Exec=/opt/st/stm32cubeide_1.19.0/stm32cubeide_wayland %F
Icon=/opt/st/stm32cubeide_1.19.0/icon.xpm
Path=/opt/st/stm32cubeide_1.19.0/
Terminal=false
StartupNotify=true
Type=Application
Categories=Development

StartupWMClass=STM32CubeIDE
```
위와 같이 맨 마지막 줄에 [[#1. 실제 WMClass 확인]] 에서 확인한 WMClass를 추가해 준다.


```bash
#database 이후 경로는 본인에게 맞게 수정!!!
update-desktop-database ~/.local/share/applications/
```
이후 터미널에 위와 같이 .desktop 파일의 변경점을 적용해 주면 해결된다.
***
